/* SPDX-License-Identifier: GPL-2.0-only */
/*
 * Copyright 2022 Collabora Ltd.
 */

#include "v4l2-tracer-common.h"

struct buffer_retrace {
	int fd;
	__u32 type; /* enum v4l2_buf_type */
	__u32 index;
	__u32 offset;
	long address_trace;
	long address_retrace;
};

struct retrace_context {
	pthread_mutex_t lock;
	/* Key is a file descriptor from the trace, value is the corresponding fd in the retrace. */
	std::unordered_map<int, int> retrace_fds;
	/* List of output and capture buffers being retraced. */
	std::list<struct buffer_retrace> buffers;
};

static struct retrace_context ctx_retrace = {
	.lock = PTHREAD_MUTEX_INITIALIZER
};

bool buffer_in_retrace_context(int fd, __u32 offset)
{
	bool buffer_in_retrace_context = false;
	pthread_mutex_lock(&ctx_retrace.lock);
	for (auto &b : ctx_retrace.buffers) {
		if ((b.fd == fd) && (b.offset == offset)) {
			buffer_in_retrace_context = true;
			break;
		}
	}
	pthread_mutex_unlock(&ctx_retrace.lock);
	return buffer_in_retrace_context;
}

int get_buffer_fd_retrace(__u32 type, __u32 index)
{
	int fd = 0; //change to -1?
	pthread_mutex_lock(&ctx_retrace.lock);
	for (auto &b : ctx_retrace.buffers) {
		if ((b.type == type) && (b.index == index)) {
			fd = b.fd;
			break;
		}
	}
	pthread_mutex_unlock(&ctx_retrace.lock);
	return fd;
}

void add_buffer_retrace(int fd, __u32 type, __u32 index, __u32 offset)
{
	pthread_mutex_lock(&ctx_retrace.lock);
	struct buffer_retrace buf = {};
	buf.fd = fd;
	buf.type = type;
	buf.index = index;
	buf.offset = offset;
	ctx_retrace.buffers.push_front(buf);
	pthread_mutex_unlock(&ctx_retrace.lock);
}

void remove_buffer_retrace(int fd)
{
	pthread_mutex_lock(&ctx_retrace.lock);
	for (auto it = ctx_retrace.buffers.begin(); it != ctx_retrace.buffers.end(); ++it) {
		if (it->fd == fd) {
			ctx_retrace.buffers.erase(it);
			break;
		}
	}
	pthread_mutex_unlock(&ctx_retrace.lock);
}

void set_buffer_address_retrace(int fd, __u32 offset, long address_trace, long address_retrace)
{
	pthread_mutex_lock(&ctx_retrace.lock);
	for (auto &b : ctx_retrace.buffers) {
		if ((b.fd == fd) && (b.offset == offset)) {
			b.address_trace = address_trace;
			b.address_retrace = address_retrace;
			break;
		}
	}
	pthread_mutex_unlock(&ctx_retrace.lock);
}

long get_retrace_address_from_trace_address(long address_trace)
{
	long address_retrace = 0;
	pthread_mutex_lock(&ctx_retrace.lock);
	for (auto &b : ctx_retrace.buffers) {
		if (b.address_trace == address_trace) {
			address_retrace = b.address_retrace;
			break;
		}
	}
	pthread_mutex_unlock(&ctx_retrace.lock);
	return address_retrace;
}

void print_buffers_retrace(void)
{
	pthread_mutex_lock(&ctx_retrace.lock);
	for (auto &b : ctx_retrace.buffers) {
		fprintf(stderr, "fd: %d, offset: %d, address_trace:%ld, address_retrace:%ld\n",
		        b.fd, b.offset, b.address_trace, b.address_retrace);
	}
	pthread_mutex_unlock(&ctx_retrace.lock);
}

/*
 * Create a new file descriptor entry in retrace context.
 * Add both the fd from the trace context and the corresponding fd from the retrace context.
 */
void add_fd(int fd_trace, int fd_retrace)
{
	std::pair<int, int> new_pair;
	new_pair = std::make_pair(fd_trace, fd_retrace);
	pthread_mutex_lock(&ctx_retrace.lock);
	ctx_retrace.retrace_fds.insert(new_pair);
	pthread_mutex_unlock(&ctx_retrace.lock);
}

int get_fd_retrace_from_fd_trace(int fd_trace)
{
	int fd_retrace = -1;
	std::unordered_map<int, int>::const_iterator it;

	pthread_mutex_lock(&ctx_retrace.lock);
	it = ctx_retrace.retrace_fds.find(fd_trace);
	if (it != ctx_retrace.retrace_fds.end())
		fd_retrace = it->second;
	pthread_mutex_unlock(&ctx_retrace.lock);

	return fd_retrace;
}

void remove_fd(int fd_trace)
{
	pthread_mutex_lock(&ctx_retrace.lock);
	ctx_retrace.retrace_fds.erase(fd_trace);
	pthread_mutex_unlock(&ctx_retrace.lock);
}

void print_fds(void)
{
	pthread_mutex_lock(&ctx_retrace.lock);
	if (ctx_retrace.retrace_fds.empty())
		fprintf(stderr, "all devices closed\n");
	for (auto it = ctx_retrace.retrace_fds.cbegin(); it != ctx_retrace.retrace_fds.cend(); ++it)
		fprintf(stderr, "fd_trace: %d, fd_retrace: %d\n", it->first, it->second);
	pthread_mutex_unlock(&ctx_retrace.lock);
}

/*
 * Convert a path from the trace file to a path in the retrace context.
 * @open_obj can be null if the user specified device paths
 * otherwise it should be open_obj generated by trace_open
*/
std::string get_path_retrace_from_path_trace(std::string path_trace, json_object *open_obj)
{
	bool is_media = path_trace.find("media") != path_trace.npos;
	bool is_video = path_trace.find("video") != path_trace.npos;

	if (is_media && getenv("V4L2_TRACER_OPTION_SET_MEDIA_DEVICE")) {
		if (is_debug())
			fprintf(stderr, "Use path set by user: %s ", getenv("V4L2_TRACER_OPTION_SET_MEDIA_DEVICE"));
		return getenv("V4L2_TRACER_OPTION_SET_MEDIA_DEVICE");
	}

	if (is_video && getenv("V4L2_TRACER_OPTION_SET_VIDEO_DEVICE")) {
		if (is_debug())
			fprintf(stderr, "Use path set by user: %s ", getenv("V4L2_TRACER_OPTION_SET_VIDEO_DEVICE"));
		return getenv("V4L2_TRACER_OPTION_SET_VIDEO_DEVICE");
	}

	std::string driver;
	json_object *driver_obj;
	if (json_object_object_get_ex(open_obj, "driver", &driver_obj))
		driver = json_object_get_string(driver_obj);

	if (driver.empty())
		return "";

	std::string path_media = get_path_media(driver);

	if (path_media.empty()) {
		fprintf(stderr, "Driver: %s not found\n", driver.c_str());
		return "";
	}

	if (is_media)
		return path_media;

	if (is_video) {
		std::list<std::string> linked_entities;
		json_object *linked_entities_obj;
		if (json_object_object_get_ex(open_obj, "linked_entities", &linked_entities_obj)) {
			for (size_t i = 0; i < array_list_length(json_object_get_array(linked_entities_obj)); i++) {
				std::string entity_name = json_object_get_string(json_object_array_get_idx(linked_entities_obj, i));
				linked_entities.push_back(entity_name);
			}
		}
		if (linked_entities.size() == 0)
			return "";

		setenv("V4L2_TRACER_PAUSE_TRACE", "true", 0);
		int media_fd = open(path_media.c_str(), O_RDONLY);
		unsetenv("V4L2_TRACER_PAUSE_TRACE");

		std::string path_video = get_path_video(media_fd, linked_entities);
		close(media_fd);
		return path_video;
	}

	return "";
}

void print_context(void)
{
	print_fds();
	print_buffers_retrace();
	fprintf(stderr, "\n");
}
