/* SPDX-License-Identifier: GPL-2.0-only */
/*
 * Copyright 2022 Collabora Ltd.
 */

#include <v4l2-info.h>
#include "trace-info.h"

struct definition {
	unsigned long val;
	const char *str;
};

static std::string val2s(unsigned long val, const definition *def)
{
	std::string s;

	if (val == 0)
		return s;

	while ((def->val) && (def->val != val))
		def++;

	if (def->val == val)
		s = def->str;

	return s;
}

std::string ioctl2s_video(unsigned long request)
{
	static constexpr definition defs[] = {
		{ VIDIOC_QUERYCAP,    "VIDIOC_QUERYCAP" },
		{ VIDIOC_ENUM_FMT,    "VIDIOC_ENUM_FMT" },
		{ VIDIOC_G_FMT,    "VIDIOC_G_FMT" },
		{ VIDIOC_S_FMT,    "VIDIOC_S_FMT" },
		{ VIDIOC_REQBUFS,    "VIDIOC_REQBUFS" },
		{ VIDIOC_QUERYBUF,    "VIDIOC_QUERYBUF" },
		{ VIDIOC_G_FBUF,    "VIDIOC_G_FBUF" },
		{ VIDIOC_S_FBUF,    "VIDIOC_S_FBUF" },
		{ VIDIOC_OVERLAY,    "VIDIOC_OVERLAY" },
		{ VIDIOC_QBUF,    "VIDIOC_QBUF" },
		{ VIDIOC_EXPBUF,    "VIDIOC_EXPBUF" },
		{ VIDIOC_DQBUF,    "VIDIOC_DQBUF" },
		{ VIDIOC_STREAMON,    "VIDIOC_STREAMON" },
		{ VIDIOC_STREAMOFF,    "VIDIOC_STREAMOFF" },
		{ VIDIOC_G_PARM,    "VIDIOC_G_PARM" },
		{ VIDIOC_S_PARM,    "VIDIOC_S_PARM" },
		{ VIDIOC_G_STD,    "VIDIOC_G_STD" },
		{ VIDIOC_S_STD,    "VIDIOC_S_STD" },
		{ VIDIOC_ENUMSTD,    "VIDIOC_ENUMSTD" },
		{ VIDIOC_ENUMINPUT,    "VIDIOC_ENUMINPUT" },
		{ VIDIOC_G_CTRL,    "VIDIOC_G_CTRL" },
		{ VIDIOC_S_CTRL,    "VIDIOC_S_CTRL" },
		{ VIDIOC_G_TUNER,    "VIDIOC_G_TUNER" },
		{ VIDIOC_S_TUNER,    "VIDIOC_S_TUNER" },
		{ VIDIOC_G_AUDIO,    "VIDIOC_G_AUDIO" },
		{ VIDIOC_S_AUDIO,    "VIDIOC_S_AUDIO" },
		{ VIDIOC_QUERYCTRL,    "VIDIOC_QUERYCTRL" },
		{ VIDIOC_QUERYMENU,    "VIDIOC_QUERYMENU" },
		{ VIDIOC_G_INPUT,    "VIDIOC_G_INPUT" },
		{ VIDIOC_S_INPUT,    "VIDIOC_S_INPUT" },
		{ VIDIOC_G_EDID,    "VIDIOC_G_EDID" },
		{ VIDIOC_S_EDID,    "VIDIOC_S_EDID" },
		{ VIDIOC_G_OUTPUT,    "VIDIOC_G_OUTPUT" },
		{ VIDIOC_S_OUTPUT,    "VIDIOC_S_OUTPUT" },
		{ VIDIOC_ENUMOUTPUT,    "VIDIOC_ENUMOUTPUT" },
		{ VIDIOC_G_AUDOUT,    "VIDIOC_G_AUDOUT" },
		{ VIDIOC_S_AUDOUT,    "VIDIOC_S_AUDOUT" },
		{ VIDIOC_G_MODULATOR,    "VIDIOC_G_MODULATOR" },
		{ VIDIOC_S_MODULATOR,    "VIDIOC_S_MODULATOR" },
		{ VIDIOC_G_FREQUENCY,    "VIDIOC_G_FREQUENCY" },
		{ VIDIOC_S_FREQUENCY,    "VIDIOC_S_FREQUENCY" },
		{ VIDIOC_CROPCAP,    "VIDIOC_CROPCAP" },
		{ VIDIOC_G_CROP,    "VIDIOC_G_CROP" },
		{ VIDIOC_S_CROP,    "VIDIOC_S_CROP" },
		{ VIDIOC_G_JPEGCOMP,    "VIDIOC_G_JPEGCOMP" },
		{ VIDIOC_S_JPEGCOMP,    "VIDIOC_S_JPEGCOMP" },
		{ VIDIOC_QUERYSTD,    "VIDIOC_QUERYSTD" },
		{ VIDIOC_TRY_FMT,    "VIDIOC_TRY_FMT" },
		{ VIDIOC_ENUMAUDIO,    "VIDIOC_ENUMAUDIO" },
		{ VIDIOC_ENUMAUDOUT,    "VIDIOC_ENUMAUDOUT" },
		{ VIDIOC_G_PRIORITY,    "VIDIOC_G_PRIORITY" },
		{ VIDIOC_S_PRIORITY,    "VIDIOC_S_PRIORITY" },
		{ VIDIOC_G_SLICED_VBI_CAP,    "VIDIOC_G_SLICED_VBI_CAP" },
		{ VIDIOC_LOG_STATUS,    "VIDIOC_LOG_STATUS" },
		{ VIDIOC_G_EXT_CTRLS,    "VIDIOC_G_EXT_CTRLS" },
		{ VIDIOC_S_EXT_CTRLS,    "VIDIOC_S_EXT_CTRLS" },
		{ VIDIOC_TRY_EXT_CTRLS,    "VIDIOC_TRY_EXT_CTRLS" },
		{ VIDIOC_ENUM_FRAMESIZES,    "VIDIOC_ENUM_FRAMESIZES" },
		{ VIDIOC_ENUM_FRAMEINTERVALS,    "VIDIOC_ENUM_FRAMEINTERVALS" },
		{ VIDIOC_G_ENC_INDEX,    "VIDIOC_G_ENC_INDEX" },
		{ VIDIOC_ENCODER_CMD,    "VIDIOC_ENCODER_CMD" },
		{ VIDIOC_TRY_ENCODER_CMD,    "VIDIOC_TRY_ENCODER_CMD" },
		{ VIDIOC_DBG_S_REGISTER,    "VIDIOC_DBG_S_REGISTER" },
		{ VIDIOC_DBG_G_REGISTER,    "VIDIOC_DBG_G_REGISTER" },
		{ VIDIOC_S_HW_FREQ_SEEK,    "VIDIOC_S_HW_FREQ_SEEK" },
		{ VIDIOC_S_DV_TIMINGS,    "VIDIOC_S_DV_TIMINGS" },
		{ VIDIOC_G_DV_TIMINGS,    "VIDIOC_G_DV_TIMINGS" },
		{ VIDIOC_DQEVENT,    "VIDIOC_DQEVENT" },
		{ VIDIOC_SUBSCRIBE_EVENT,    "VIDIOC_SUBSCRIBE_EVENT" },
		{ VIDIOC_UNSUBSCRIBE_EVENT,    "VIDIOC_UNSUBSCRIBE_EVENT" },
		{ VIDIOC_CREATE_BUFS,    "VIDIOC_CREATE_BUFS" },
		{ VIDIOC_PREPARE_BUF,    "VIDIOC_PREPARE_BUF" },
		{ VIDIOC_G_SELECTION,    "VIDIOC_G_SELECTION" },
		{ VIDIOC_S_SELECTION,    "VIDIOC_S_SELECTION" },
		{ VIDIOC_DECODER_CMD,    "VIDIOC_DECODER_CMD" },
		{ VIDIOC_TRY_DECODER_CMD,    "VIDIOC_TRY_DECODER_CMD" },
		{ VIDIOC_ENUM_DV_TIMINGS,    "VIDIOC_ENUM_DV_TIMINGS" },
		{ VIDIOC_QUERY_DV_TIMINGS,    "VIDIOC_QUERY_DV_TIMINGS" },
		{ VIDIOC_DV_TIMINGS_CAP,    "VIDIOC_DV_TIMINGS_CAP" },
		{ VIDIOC_ENUM_FREQ_BANDS,    "VIDIOC_ENUM_FREQ_BANDS" },
		{ VIDIOC_DBG_G_CHIP_INFO,    "VIDIOC_DBG_G_CHIP_INFO" },
		{ VIDIOC_QUERY_EXT_CTRL,    "VIDIOC_QUERY_EXT_CTRL" },
		{ BASE_VIDIOC_PRIVATE,    "BASE_VIDIOC_PRIVATE" },
		{ 0, nullptr }
	};
	return val2s(request, defs);
}

std::string ioctl2s_media(unsigned long request)
{
	static constexpr definition defs[] = {
		{ MEDIA_IOC_DEVICE_INFO,    "MEDIA_IOC_DEVICE_INFO" },
		{ MEDIA_IOC_ENUM_ENTITIES,    "MEDIA_IOC_ENUM_ENTITIES" },
		{ MEDIA_IOC_ENUM_LINKS,    "MEDIA_IOC_ENUM_LINKS" },
		{ MEDIA_IOC_SETUP_LINK,    "MEDIA_IOC_SETUP_LINK" },
		{ MEDIA_IOC_G_TOPOLOGY,    "MEDIA_IOC_G_TOPOLOGY" },
		{ MEDIA_IOC_REQUEST_ALLOC,    "MEDIA_IOC_REQUEST_ALLOC" },
		{ MEDIA_REQUEST_IOC_QUEUE,    "MEDIA_REQUEST_IOC_QUEUE" },
		{ MEDIA_REQUEST_IOC_REINIT,    "MEDIA_REQUEST_IOC_REINIT" },
		{ 0, nullptr }
	};
	return val2s(request, defs);
}

std::string ctrltype2s(__u32 val)
{
	static constexpr definition defs[] = {
		{ V4L2_CTRL_TYPE_INTEGER,    "V4L2_CTRL_TYPE_INTEGER" },
		{ V4L2_CTRL_TYPE_BOOLEAN,    "V4L2_CTRL_TYPE_BOOLEAN" },
		{ V4L2_CTRL_TYPE_MENU,    "V4L2_CTRL_TYPE_MENU" },
		{ V4L2_CTRL_TYPE_BUTTON,    "V4L2_CTRL_TYPE_BUTTON" },
		{ V4L2_CTRL_TYPE_INTEGER64,    "V4L2_CTRL_TYPE_INTEGER64" },
		{ V4L2_CTRL_TYPE_CTRL_CLASS,    "V4L2_CTRL_TYPE_CTRL_CLASS" },
		{ V4L2_CTRL_TYPE_STRING,    "V4L2_CTRL_TYPE_STRING" },
		{ V4L2_CTRL_TYPE_BITMASK,    "V4L2_CTRL_TYPE_BITMASK" },
		{ V4L2_CTRL_TYPE_INTEGER_MENU,    "V4L2_CTRL_TYPE_INTEGER_MENU" },
		{ V4L2_CTRL_COMPOUND_TYPES,    "V4L2_CTRL_COMPOUND_TYPES" },
		{ V4L2_CTRL_TYPE_U8,    "V4L2_CTRL_TYPE_U8" },
		{ V4L2_CTRL_TYPE_U16,    "V4L2_CTRL_TYPE_U16" },
		{ V4L2_CTRL_TYPE_U32,    "V4L2_CTRL_TYPE_U32" },
		{ V4L2_CTRL_TYPE_AREA,    "V4L2_CTRL_TYPE_AREA" },
		{ V4L2_CTRL_TYPE_HDR10_CLL_INFO,    "V4L2_CTRL_TYPE_HDR10_CLL_INFO" },
		{ V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY,    "V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY" },
		{ V4L2_CTRL_TYPE_H264_SPS,    "V4L2_CTRL_TYPE_H264_SPS" },
		{ V4L2_CTRL_TYPE_H264_PPS,    "V4L2_CTRL_TYPE_H264_PPS" },
		{ V4L2_CTRL_TYPE_H264_SCALING_MATRIX,    "V4L2_CTRL_TYPE_H264_SCALING_MATRIX" },
		{ V4L2_CTRL_TYPE_H264_SLICE_PARAMS,    "V4L2_CTRL_TYPE_H264_SLICE_PARAMS" },
		{ V4L2_CTRL_TYPE_H264_DECODE_PARAMS,    "V4L2_CTRL_TYPE_H264_DECODE_PARAMS" },
		{ V4L2_CTRL_TYPE_H264_PRED_WEIGHTS,    "V4L2_CTRL_TYPE_H264_PRED_WEIGHTS" },
		{ V4L2_CTRL_TYPE_FWHT_PARAMS,    "V4L2_CTRL_TYPE_FWHT_PARAMS" },
		{ V4L2_CTRL_TYPE_VP8_FRAME,    "V4L2_CTRL_TYPE_VP8_FRAME" },
		{ V4L2_CTRL_TYPE_MPEG2_QUANTISATION,    "V4L2_CTRL_TYPE_MPEG2_QUANTISATION" },
		{ V4L2_CTRL_TYPE_MPEG2_SEQUENCE,    "V4L2_CTRL_TYPE_MPEG2_SEQUENCE" },
		{ V4L2_CTRL_TYPE_MPEG2_PICTURE,    "V4L2_CTRL_TYPE_MPEG2_PICTURE" },
		{ V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR,    "V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR" },
		{ V4L2_CTRL_TYPE_VP9_FRAME,    "V4L2_CTRL_TYPE_VP9_FRAME" },
		{ 0, nullptr }
	};
	return val2s(val, defs);
}

std::string capflag2s(unsigned long cap)
{
	static constexpr flag_def def[] = {
		{ V4L2_CAP_VIDEO_M2M_MPLANE,    "V4L2_CAP_VIDEO_M2M_MPLANE" },
		{ V4L2_CAP_VIDEO_CAPTURE, "V4L2_CAP_VIDEO_CAPTURE" },
		{ V4L2_CAP_VIDEO_OUTPUT, "V4L2_CAP_VIDEO_OUTPUT" },
		{ V4L2_CAP_VIDEO_OVERLAY, "V4L2_CAP_VIDEO_OVERLAY" },
		{ V4L2_CAP_VBI_CAPTURE, "V4L2_CAP_VBI_CAPTURE" },
		{ V4L2_CAP_VBI_OUTPUT, "V4L2_CAP_VBI_OUTPUT" },
		{ V4L2_CAP_SLICED_VBI_CAPTURE, "V4L2_CAP_SLICED_VBI_CAPTURE" },
		{ V4L2_CAP_SLICED_VBI_OUTPUT, "V4L2_CAP_SLICED_VBI_OUTPUT" },
		{ V4L2_CAP_RDS_CAPTURE, "V4L2_CAP_RDS_CAPTURE" },
		{ V4L2_CAP_VIDEO_OUTPUT_OVERLAY, "V4L2_CAP_VIDEO_OUTPUT_OVERLAY" },
		{ V4L2_CAP_HW_FREQ_SEEK, "V4L2_CAP_HW_FREQ_SEEK" },
		{ V4L2_CAP_RDS_OUTPUT, "V4L2_CAP_RDS_OUTPUT" },
		{ V4L2_CAP_VIDEO_CAPTURE_MPLANE, "V4L2_CAP_VIDEO_CAPTURE_MPLANE" },
		{ V4L2_CAP_VIDEO_OUTPUT_MPLANE, "V4L2_CAP_VIDEO_OUTPUT_MPLANE" },
		{ V4L2_CAP_VIDEO_M2M_MPLANE, "V4L2_CAP_VIDEO_M2M_MPLANE" },
		{ V4L2_CAP_VIDEO_M2M, "V4L2_CAP_VIDEO_M2M" },
		{ V4L2_CAP_TUNER, "V4L2_CAP_TUNER" },
		{ V4L2_CAP_AUDIO, "V4L2_CAP_AUDIO" },
		{ V4L2_CAP_RADIO, "V4L2_CAP_RADIO" },
		{ V4L2_CAP_MODULATOR, "V4L2_CAP_MODULATOR" },
		{ V4L2_CAP_SDR_CAPTURE, "V4L2_CAP_SDR_CAPTURE" },
		{ V4L2_CAP_EXT_PIX_FORMAT, "V4L2_CAP_EXT_PIX_FORMAT" },
		{ V4L2_CAP_SDR_OUTPUT, "V4L2_CAP_SDR_OUTPUT" },
		{ V4L2_CAP_META_CAPTURE, "V4L2_CAP_META_CAPTURE" },
		{ V4L2_CAP_READWRITE, "V4L2_CAP_READWRITE" },
		{ V4L2_CAP_ASYNCIO, "V4L2_CAP_ASYNCIO" },
		{ V4L2_CAP_STREAMING, "V4L2_CAP_STREAMING" },
		{ V4L2_CAP_META_OUTPUT, "V4L2_CAP_META_OUTPUT" },
		{ V4L2_CAP_TOUCH, "V4L2_CAP_TOUCH" },
		{ V4L2_CAP_IO_MC, "V4L2_CAP_IO_MC" },
		{ V4L2_CAP_DEVICE_CAPS, "V4L2_CAP_DEVICE_CAPS" },
		{ 0, nullptr }
	};
	return flags2s(cap, def);
}

std::string bufsyncflag2s(unsigned long flag)
{
	static constexpr flag_def def[] = {
		{ DMA_BUF_SYNC_READ , "DMA_BUF_SYNC_READ " },
		{ DMA_BUF_SYNC_WRITE, "DMA_BUF_SYNC_WRITE" },
		{ DMA_BUF_SYNC_RW , "DMA_BUF_SYNC_RW " },
		{ DMA_BUF_SYNC_START , "DMA_BUF_SYNC_START" },
		{ DMA_BUF_SYNC_END, "DMA_BUF_SYNC_END" },
		{ 0, nullptr }
	};
	return flags2s(flag, def);
}

std::string vp8_segment_flag2s(unsigned long flag)
{
	static constexpr flag_def def[] = {
		{ V4L2_VP8_SEGMENT_FLAG_ENABLED, "V4L2_VP8_SEGMENT_FLAG_ENABLED" },
		{ V4L2_VP8_SEGMENT_FLAG_UPDATE_MAP, "V4L2_VP8_SEGMENT_FLAG_UPDATE_MAP" },
		{ V4L2_VP8_SEGMENT_FLAG_UPDATE_FEATURE_DATA, "V4L2_VP8_SEGMENT_FLAG_UPDATE_FEATURE_DATA" },
		{ V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE, "V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE" },
		{ 0, nullptr }
	};
	return flags2s(flag, def);
}

std::string vp8_loop_filter_flag2s(unsigned long flag)
{
	static constexpr flag_def def[] = {
		{ V4L2_VP8_LF_ADJ_ENABLE, "V4L2_VP8_LF_ADJ_ENABLE" },
		{ V4L2_VP8_LF_DELTA_UPDATE, "V4L2_VP8_LF_DELTA_UPDATE" },
		{ V4L2_VP8_LF_FILTER_TYPE_SIMPLE, "V4L2_VP8_LF_FILTER_TYPE_SIMPLE" },
		{ 0, nullptr }
	};
	return flags2s(flag, def);
}

std::string vp8_frame_flag2s(unsigned long flag)
{
	static constexpr flag_def def[] = {
		{ V4L2_VP8_FRAME_FLAG_KEY_FRAME, "V4L2_VP8_FRAME_FLAG_KEY_FRAME" },
		{ V4L2_VP8_FRAME_FLAG_EXPERIMENTAL, "V4L2_VP8_FRAME_FLAG_EXPERIMENTAL" },
		{ V4L2_VP8_FRAME_FLAG_SHOW_FRAME, "V4L2_VP8_FRAME_FLAG_SHOW_FRAME" },
		{ V4L2_VP8_FRAME_FLAG_MB_NO_SKIP_COEFF, "V4L2_VP8_FRAME_FLAG_MB_NO_SKIP_COEFF" },
		{ V4L2_VP8_FRAME_FLAG_SIGN_BIAS_GOLDEN, "V4L2_VP8_FRAME_FLAG_SIGN_BIAS_GOLDEN" },
		{ V4L2_VP8_FRAME_FLAG_SIGN_BIAS_ALT, "V4L2_VP8_FRAME_FLAG_SIGN_BIAS_ALT" },
		{ 0, nullptr }
	};
	return flags2s(flag, def);
}

std::string ver2s(unsigned int version)
{
	char buf[16];
	sprintf(buf, "%d.%d.%d", version >> 16, (version >> 8) & 0xff, version & 0xff);
	return buf;
}

std::string which2s(unsigned long which)
{
	std::string s = "unknown";

	switch (which) {
	case V4L2_CTRL_WHICH_CUR_VAL:
		s = "V4L2_CTRL_WHICH_CUR_VAL";
		break;
	case V4L2_CTRL_WHICH_DEF_VAL:
		s= "V4L2_CTRL_WHICH_DEF_VAL";
		break;
	case V4L2_CTRL_WHICH_REQUEST_VAL:
		s = "V4L2_CTRL_WHICH_REQUEST_VAL";
		break;
	default:
		break;
	}

	return s;
}

std::string ctrlclass2s(__u32 id)
{
	static constexpr definition defs[] = {
		{ V4L2_CTRL_CLASS_USER, "V4L2_CTRL_CLASS_USER" },
		{ V4L2_CTRL_CLASS_CODEC,	"V4L2_CTRL_CLASS_CODEC" },
		{ V4L2_CTRL_CLASS_CAMERA, "V4L2_CTRL_CLASS_CAMERA" },
		{ V4L2_CTRL_CLASS_FM_TX, "V4L2_CTRL_CLASS_FM_TX" },
		{ V4L2_CTRL_CLASS_FLASH, "V4L2_CTRL_CLASS_FLASH" },
		{ V4L2_CTRL_CLASS_JPEG,	"V4L2_CTRL_CLASS_JPEG" },
		{ V4L2_CTRL_CLASS_IMAGE_SOURCE,	"V4L2_CTRL_CLASS_IMAGE_SOURCE" },
		{ V4L2_CTRL_CLASS_IMAGE_PROC, "V4L2_CTRL_CLASS_IMAGE_PROC" },
		{ V4L2_CTRL_CLASS_DV, "V4L2_CTRL_CLASS_DV" },
		{ V4L2_CTRL_CLASS_FM_RX, "V4L2_CTRL_CLASS_FM_RX" },
		{ V4L2_CTRL_CLASS_RF_TUNER, "V4L2_CTRL_CLASS_RF_TUNER" },
		{ V4L2_CTRL_CLASS_DETECT, "V4L2_CTRL_CLASS_DETECT" },
		{ V4L2_CTRL_CLASS_CODEC_STATELESS, "V4L2_CTRL_CLASS_CODEC_STATELESS" },
		{ V4L2_CTRL_CLASS_COLORIMETRY, "V4L2_CTRL_CLASS_COLORIMETRY" },
		{ 0, nullptr }
	};
	return val2s(id & 0xff0000, defs);
}

std::string request_buffers_flag2s(unsigned int flag)
{
	static constexpr flag_def def[] = {
		{ V4L2_MEMORY_FLAG_NON_COHERENT, "V4L2_MEMORY_FLAG_NON_COHERENT" },
		{ 0, nullptr }
	};
	return flags2s(flag, def);
}

std::string v4l2_memory2s(__u32 id)
{
	static constexpr definition defs[] = {
		{ V4L2_MEMORY_MMAP, "V4L2_MEMORY_MMAP" },
		{ V4L2_MEMORY_USERPTR, "V4L2_MEMORY_USERPTR" },
		{ V4L2_MEMORY_OVERLAY, "V4L2_MEMORY_OVERLAY" },
		{ V4L2_MEMORY_DMABUF, "V4L2_MEMORY_DMABUF" },
		{ 0, nullptr }
	};
	return val2s(id, defs);
}

std::string tc_type2s(__u32 id)
{
	static constexpr definition defs[] = {
		{ V4L2_TC_TYPE_24FPS, "V4L2_TC_TYPE_24FPS" },
		{ V4L2_TC_TYPE_25FPS, "V4L2_TC_TYPE_25FPS" },
		{ V4L2_TC_TYPE_30FPS, "V4L2_TC_TYPE_30FPS" },
		{ V4L2_TC_TYPE_50FPS, "V4L2_TC_TYPE_50FPS" },
		{ V4L2_TC_TYPE_60FPS, "V4L2_TC_TYPE_60FPS" },
		{ 0, nullptr }
	};
	return val2s(id, defs);
}

std::string tc_flag2s(unsigned int flag)
{
	static constexpr flag_def def[] = {
		{ V4L2_TC_FLAG_DROPFRAME, "V4L2_TC_FLAG_DROPFRAME" },
		{ V4L2_TC_FLAG_COLORFRAME, "V4L2_TC_FLAG_COLORFRAME" },
		{ V4L2_TC_USERBITS_field, "V4L2_TC_USERBITS_field" },
		{ V4L2_TC_USERBITS_USERDEFINED, "V4L2_TC_USERBITS_USERDEFINED" },
		{ V4L2_TC_USERBITS_8BITCHARS, "V4L2_TC_USERBITS_8BITCHARS" },
		{ 0, nullptr }
	};
	return flags2s(flag, def);
}
